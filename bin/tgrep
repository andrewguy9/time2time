#!/usr/bin/env python
# A version of grep which filters by timestamp.

import argparse
from signal import signal, SIGPIPE, SIG_DFL
from _strptime import TimeRE as formatGenerator
import sys
from time import strptime
from time2time.format import get_format_string

parser = argparse.ArgumentParser(description='A version of grep which filters by timestamp.')
parser.add_argument('--format', type=str, dest='format', action='store', required=True, help='format string for timestamps')
parser.add_argument('--start', type=str, dest='start', action='store', help='match values greather than this')
parser.add_argument('--stop', type=str, dest='stop', action='store', help='match values less than this')
parser.add_argument('files', nargs='*', default=['/dev/stdin'], help='list of files to read. If no files are specified, reads from stdin')

fg = formatGenerator()

def generate_constraints(start,stop,time_format):

    constraints = []
    # We only want to print lines if we know the date of the lines were looking at.
    constraints.append( lambda x: x is not None )
    if start:
        lower_bound = strptime(start, time_format)
        constraints.append( lambda x: x > lower_bound )
    if stop:
        upper_bound = strptime(stop, time_format)
        constraints.append( lambda x: x < upper_bound )
    return constraints

def split_line(expr, line):
    match = expr.match(line)
    if match:
        date = match.group()
        rest = line[match.end():]
        return (date,rest)
    else:
        return (None,line)

def main():
    args = parser.parse_args()
    time_format = get_format_string(args.format)
    print time_format
    constraints = generate_constraints(args.start,args.stop,time_format)

    format_expr = fg.compile(time_format)

    for fname in args.files:
        with open(fname, 'r') as f:
            time = None
            for line in f.readlines():
                (t,r) = split_line(format_expr, line)
                if t:
                    time = strptime(t, time_format)
                if not all( map(lambda foo: foo(time), constraints) ):
                    continue
                try:
                    sys.stdout.write(line)
                except IOError as ioe:
                    return
                except Exception as e:
                    raise e
    sys.stdout.flush()

if __name__ == "__main__":
    main()

